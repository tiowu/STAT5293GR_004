X_std = scale(X)
D = as.matrix(dist(X_std, method = "euclidean"))
pacman::p_load(nbpMatching)
indicies_pairs = as.matrix(nonbimatch(distancematrix(D))$matches[, c("Group1.Row", "Group2.Row")])
rm(D)
Wpm = matrix(NA, n, R)
for (r in 1:R) {
w = rep(NA, n)
for (pair in 1:nrow(indicies_pairs)) {
pair_indices = indicies_pairs[pair, ]
treated = sample(pair_indices, 1)     # randomly pick one to treat
control = setdiff(pair_indices, treated)
w[treated] = 1
w[control] = 0
}
Wpm[, r] = w
}
set.seed(1)
balances_rerand = apply(Wrerand, 2, balance_all_covariates)
## Bernoulli regression
#let's look at the Pima diabetes data again
pima = na.omit(MASS::Pima.tr2)
pima$type = ifelse(pima$type == "Yes", 1, 0)
p = ncol(pima) - 1 #-1 for the response
p
#since we're doing bernoulli regression, we need a link function
family_function = binomial(link = "logit")
#and let's fit the generalized linear model on all features
full_mod = glm(type ~ ., pima, family = family_function)
summary(full_mod)
#it displays the Wald tests that are computed via the sqrt of the diagonal
#entries from the Fisher information matrix and computing the matrix is not super difficult;
#see here: https://web.stanford.edu/class/archive/stats/stats200/stats200.1172/Lecture26.pdf
#there is also a measure of fit called "deviance" which we don't have time to go into
#the AIC reported is the same that we studied from MATH 341
#notice how we have the log likelihood easily accessible from R
as.numeric(logLik(full_mod))
## Bernoulli regression
#let's look at the Pima diabetes data again
pima = na.omit(MASS::Pima.tr2)
pima$type = ifelse(pima$type == "Yes", 1, 0)
p = ncol(pima) - 1 #-1 for the response
p
#since we're doing bernoulli regression, we need a link function
family_function = binomial(link = "logit")
#and let's fit the generalized linear model on all features
full_mod = glm(type ~ ., pima, family = family_function)
summary(full_mod)
# (a) Simulate shots with a constant 40% chance of making each shot
set.seed(123) # For reproducibility
n_tries <- 10
p_success <- 0.4
# rbinom generates a random number from the binomial distribution
shots_made_a <- rbinom(n = 1, size = n_tries, prob = p_success)
print(shots_made_a)
rbinom
set.seed(17)
r_num = rbinom(10, 1, 0.4)
rbinom
set.seed(17)
r_num = rbinom(10, 1, 0.4)
r_num
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
r_num = rbinom(10, 1, 0.4)
sum(r_num)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
tries = 10
shots_made = rep(NA, tries)
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
}
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made = rbinom(1, 1, 0.1*i)
}
shots_made
shots_made
tries = 10
shots_made = rep(NA, tries)
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in seq(1:10)) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in 1:10) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
shots_made
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made = rbinom(10, 1, probs)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
rbinom(10, 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
rbinom(10, prob = 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
rbinom(1, 10, prob = 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
rbinom(1, 10, prob = 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(1, 10, prob = 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(18)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(17)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(16)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(15)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(14)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(13)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(12)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(11)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(19)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(20)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(21)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(22)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(23)
shots_made = rbinom(10, 1, 0.4)
sum(shots_made)
# equivalence
rbinom(n = 1, size = 10, prob = 0.4)
set.seed(23)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(22)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(21)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(20)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(12)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(17)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
set.seed(18)
tries = 10
shots_made = rep(NA, tries)
for (i in 1:tries) {
shots_made[i] = rbinom(1, 1, 0.1*i)
}
sum(shots_made)
# equivalence
probs = seq(0.1, 1, by = 0.1)
shots_made_1 = rbinom(10, 1, probs)
sum(shots_made_1)
setwd("~/Downloads/1 STAT5293G004 Gelman/STAT_5293/Homeworks")
# 1. Install the C++ toolchain and the CmdStan engine
# This might take 5-10 minutes because it's compiling the engine!
cmdstanr::install_cmdstan(cores = 4)
# 2. Tell R to look in that default location
cmdstanr::set_cmdstan_path()
# 3. Double-check it worked. This should print a path, not an error.
cmdstanr::cmdstan_path()
#install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
#example(stan_model, package = "rstan", run.dontrun = TRUE)
stan_data = list(n = 100, x = predictor, y = y) #prepare the data
#install.packages("arm")
library(arm)
set.seed(21)
n = 100
beta_0 = 1 # true intercept
beta_1 = 2 # true slope
predictor = runif(n, 0, 4)
residuals = rnorm(n, 0, 3) #residual standard deviation 3
y = beta_0 + predictor * beta_1 + residuals
fitted_linear_model = lm(y ~ predictor)
display(fitted_linear_model)
if (abs(coef(fitted_linear_model)[1] - beta_0) <= se.coef(fitted_linear_model)[1]) {
print("Intercept estimate falls within 1 standard error of the true intercept value.")
}
if (abs(coef(fitted_linear_model)[2] - beta_1) <= se.coef(fitted_linear_model)[2]) {
print("Slope estimate falls within 1 standard error of the true slope value.")
}
#install.packages("rstanarm")
library(rstanarm)
stan_linear_model = stan_glm(y ~ predictor, data = data.frame(y, predictor), refresh = 0) # add refresh = 0 to hide the sampling progress
print(stan_linear_model)
#cmdstanr::install_cmdstan(cores = 4) #install the C++ toolchain and the CmdStan engine
#install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
#example(stan_model, package = "rstan", run.dontrun = TRUE)
stan_data = list(n = 100, x = predictor, y = y) #prepare the data
mod = cmdstan_model("linear_model.stan")        #compile the model
fit_cmdstan = mod$sample(
data = stan_data,
seed = 21,
chains = 4,
parallel_chains = 4,
refresh = 0
)
fit_cmdstan$print()
#cmdstanr::install_cmdstan(cores = 4) #install the C++ toolchain and the CmdStan engine
#install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
#example(stan_model, package = "rstan", run.dontrun = TRUE)
stan_data = list(n = 100, x = predictor, y = y) #prepare the data
mod = cmdstan_model("linear_model.stan")        #compile the model
fit_cmdstan = mod$sample(
data = stan_data,
seed = 21,
chains = 4,
parallel_chains = 4,
refresh = 0
)
fit_cmdstan$print()
